// Name: name-shuffler.pde
// Author: Oliver Steele
// Source: https://gist.github.com/osteele/3351fb073ab0ea4e1568b7d7e9310447
// License: MIT
//
// Instructions:
// Edit a list of names into nameStrings, below.
// Run the program. It presents them shuffled.
// Click to shuffle agin.
import processing.sound.*;

final int MOUSE_CLICK_SHUFFLE_DURATION = 60;
final int AUTO_SHUFFLE_COUNT = 5;
final int AUTO_SHUFFLE_MAX_DURATION = 40;
final int AUTO_SHUFFLE_MIN_DURATION = 15;

StringList names;
ArrayList<PVector> positions;
ArrayList<PVector> startPositions;
ArrayList<PVector> endPositions;
ArrayList<PVector> currentPositions;

SoundFile clickSound, chimeSound;

int startFrame = 15;
int autoshuffleCount = AUTO_SHUFFLE_COUNT;

// Test data generated by fzaninotto/Faker
String defaultNameStrings[] = {
  "Kristin & Ramona",
  "Delphia & Sarah",
  "Letha & Maxime",
  "Dahlia, Kolby, & Dewitt",
  "Sierra & Theron",
};

String nameStrings[];

void setup() {
  size(500, 500);
  //fullScreen();
  colorMode(HSB);

  clickSound = new SoundFile(this, "60013__qubodup__whoosh.mp3");
  chimeSound = new SoundFile(this, "75336__neotone__chime1.mp3");

  String[] namesArray = loadStrings("names.txt");
  names = stringListFromArray(namesArray != null ? namesArray : defaultNameStrings);
  autoshuffleCount = names.size();

  final int columns = ceil(sqrt(names.size() / 3));
  final int rows = ceil(names.size() / columns);
  for (float textSize = 180; textSize > 12; textSize *= 0.8) {
    textSize(textSize);
    final float textLineHeight = textAscent() + textDescent();
    final float textLeading = textLineHeight * 1.5;
    final float textHeight = (rows - 1) * textLeading + textLineHeight;

    float textWidth = 0;
    positions = new ArrayList<PVector>();
    for (int i = 0; i < names.size(); i++) {
      textWidth = max(textWidth, textWidth(names.get(i)));
    }
    final float columnWidth = textWidth + 50;
    final float columnTop = (height - textHeight + textLeading) / 2;
    float x = (width - columns * columnWidth) / 2 - columnWidth;
    float y = 0;
    for (int i = 0; i < names.size(); i++) {
      if (i % rows == 0) {
        x += columnWidth;
        y = columnTop;
      }
      positions.add(new PVector(x, floor(y)));
      y += textLeading;
    }
    if (columns * columnWidth < width && textHeight < height) break;
  }

  startPositions = (ArrayList<PVector>) positions.clone();
  currentPositions = (ArrayList<PVector>) positions.clone();
  endPositions = startPositions;
}

void draw() {
  background(100);

  fill(220);
  final float animationDuration = autoshuffleCount >= 0
    ? map(autoshuffleCount, AUTO_SHUFFLE_COUNT, 0, AUTO_SHUFFLE_MAX_DURATION, AUTO_SHUFFLE_MIN_DURATION)
    : MOUSE_CLICK_SHUFFLE_DURATION;
  final float s0 = clampMap(frameCount - startFrame, 0, animationDuration, 0, 1);
  final float s = easeInOutCubic(s0);
  for (int i = 0; i < names.size(); i++) {
    final String name = names.get(i);
    final float y0 = currentPositions.get(i).y;
    final PVector pos = PVector.lerp(startPositions.get(i), endPositions.get(i), s);
    final int n = ceil(abs(pos.y - y0));
    for (int j = 0; j < n; j++) {
      fill(map(i, 0, names.size(), 0, 255), 200, 250, map(j, 0, n, 10, 250));
      text(name, pos.x, map(j, 0, n, y0, pos.y));
    }
    fill(map(i, 0, names.size(), 0, 255), 120, 250);
    currentPositions.set(i, new PVector(pos.x, floor(pos.y)));
    text(name, pos.x, pos.y);
  }
  if (s >= 1) {
    if (--autoshuffleCount >= 0) {
      startShuffle();
    } else if (autoshuffleCount == -1) {
      chimeSound.play();
    }
  }
}

void mousePressed() {
  autoshuffleCount = 0;
  startShuffle();
}

void keyPressed() {
  if (key == 'q') {
    exit();
  }
}

void startShuffle() {
  startFrame = frameCount;
  startPositions = currentPositions;
  endPositions = (ArrayList<PVector>) shuffled(positions);
  clickSound.play();
}

ArrayList shuffled(ArrayList lst) {
  IntList indices = new IntList();
  ArrayList result = new ArrayList();
  for (int i = 0; i < lst.size(); i++) {
    indices.append(i);
  }
  indices.shuffle();
  for (int i = 0; i < indices.size(); i++) {
    result.add(lst.get(indices.get(i)));
  }
  return result;
}

float clamp(float value, float low, float high) {
  return max(low, min(high, value));
}

float clampMap(float value, float start1, float stop1, float start2, float stop2) {
  float unclamped = map(value, start1, stop1, start2, stop2);
  return clamp(unclamped, start2, stop2);
}

float easeInOutCubic(float x) {
  return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;
}

StringList stringListFromArray(String[] strings) {
  StringList result = new StringList();
  for (int i = 0; i < strings.length; i++) {
    result.append(strings[i]);
  }
  return result;
}
